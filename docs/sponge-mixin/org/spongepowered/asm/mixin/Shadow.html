<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Shadow (Mixin 0.9.2+mixin.0.8.2 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.spongepowered.asm.mixin, annotation type: Shadow">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">Optional</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">Element</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.spongepowered.asm.mixin</a></div>
<h1 title="Annotation Type Shadow" class="title">Annotation Type Shadow</h1>
</div>
<section class="description">
<hr>
<pre>@Target({METHOD,FIELD})
@Retention(RUNTIME)
public @interface <span class="type-name-label">Shadow</span></pre>
<div class="block">Used to indicate a Mixin class member which is acting as a placeholder for a
 method or field in the target class</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== -->
<li>
<section class="member-summary" id="annotation.type.optional.element.summary">
<h2>Optional Element Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Optional Elements</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Optional Element</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>java.lang.String[]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aliases()">aliases</a></span></code></th>
<td class="col-last">
<div class="block">Supplies possible aliases for this shadow member.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#prefix()">prefix</a></span></code></th>
<td class="col-last">
<div class="block">In general, shadow methods can be declared using their name in the
 target class as you would expect, however we run into a problem when we
 want to mix in a method with the same name and arguments, but a different
 return type to the shadow method.</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#remap()">remap</a></span></code></th>
<td class="col-last">
<div class="block">By default, the annotation processor will attempt to locate an
 obfuscation mapping for all <a href="Shadow.html" title="annotation in org.spongepowered.asm.mixin"><code>Shadow</code></a> methods since it is
 anticipated that in general the target of a <a href="Shadow.html" title="annotation in org.spongepowered.asm.mixin"><code>Shadow</code></a> annotation
 will be an obfuscated field or method in the target class.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
</ul>
</section>
<section class="details" id="annotation.type.element.detail">
<ul class="details-list">
<!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== -->
<li>
<section class="member-details">
<h2>Element Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="prefix()">
<h3>prefix</h3>
<div class="member-signature"><span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">prefix</span></div>
<div class="block"><p>In general, shadow methods can be declared using their name in the
 target class as you would expect, however we run into a problem when we
 want to mix in a method with the same name and arguments, but a different
 return type to the shadow method. While the JVM itself will happily
 support methods with signatures that differ only on return type, the
 compiler itself does not. This poses a problem, since we have no way to
 leverage this behaviour since our mixin class will not compile.</p>

 <p>To circumvent this compiler limitation, the prefix option can be used.
 By specifying a prefix for the shadow method, it is subsequently possible
 to compile the mixin class, the specified prefix will then be stripped
 from the method name prior to applying the mixin, and everything will
 work as expected. You may either use the default prefix: "shadow$", or
 you may specify your own. It is good practice to specify the prefix if
 you are using it, regardless of whether you use the default or not. For
 example consider the intrinsic readability of the following snippets</p>:

 <blockquote><pre>
     &#64;Shadow abstract void someMethod(int arg1, int arg2);
     &#64;Shadow abstract void shadow$someMethod(int arg1, int arg2);
     &#64;Shadow(prefix = "shadow$") abstract void shadow$someMethod(int arg1, int arg2);
     &#64;Shadow(prefix = "foo$") abstract void foo$someMethod(int arg1, int arg2);
 </pre></blockquote>

 <p>All of these declarations are semantically equivalent, however the
 third and fourth are the most expressive in terms of making their
 intentions clear, and thus specifying prefix is recommended, since it
 aids readability and maintainability.</p>

 <p>Note that specifying a <em>prefix</em> does not <b>enforce</b> use of
 the prefix, the behaviour of <em>prefix</em> is such that the prefix will
 be stripped from the start of the method name <em>as long as the method
 name actually starts with the prefix</em>! This has important
 repercussions since if the annotation value does not match the method
 prefix then <em>no renaming will take place</em> likey resulting in a
 failure state indicated by an <a href="transformer/throwables/InvalidMixinException.html" title="class in org.spongepowered.asm.mixin.transformer.throwables"><code>InvalidMixinException</code></a> at run
 time.</p>
 
 <p>Prefixes on shadow fields are considered an error condition and don't
 have any purpose either way, since the scenario described above cannot
 actually occur with fields.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the shadow prefix</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>"shadow$"</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="remap()">
<h3>remap</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="member-name">remap</span></div>
<div class="block">By default, the annotation processor will attempt to locate an
 obfuscation mapping for all <a href="Shadow.html" title="annotation in org.spongepowered.asm.mixin"><code>Shadow</code></a> methods since it is
 anticipated that in general the target of a <a href="Shadow.html" title="annotation in org.spongepowered.asm.mixin"><code>Shadow</code></a> annotation
 will be an obfuscated field or method in the target class. However since
 it is possible to also apply mixins to non-obfuscated targets (or non-
 obfuscated methods in obfuscated targets, such as methods added by Forge)
 it may be desirable to suppress the compiler warning which would
 otherwise be generated. Setting this value to <em>false</em> will cause
 the annotation processor to skip this annotation when attempting to build
 the obfuscation table for the mixin.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>True to instruct the annotation processor to search for
      obfuscation mappings for this annotation</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>true</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aliases()">
<h3>aliases</h3>
<div class="member-signature"><span class="return-type">java.lang.String[]</span>&nbsp;<span class="member-name">aliases</span></div>
<div class="block">Supplies possible aliases for this shadow member. This should <b>only</b>
 be used in the following scenarios:
 
 <ul>
   <li>When shadowing a sythetic field or method which can have different
     names at development time because it is regenerated by the compiler.
   </li>
   <li>When another mod or transformer is known to change the name of a
   field</li>
 </ul>
 
 <p><b>Only private</b> members may be given aliases. This is because
 aliases can only be calculated when the mixin is applied and thus would
 otherwise invalidate the calculated class metadata if another mixin had
 already been applied in the hierarchy.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Aliases for this member</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>{}</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">Optional</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">Element</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
