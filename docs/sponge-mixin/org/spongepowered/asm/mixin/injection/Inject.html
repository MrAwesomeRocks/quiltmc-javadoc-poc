<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Inject (Mixin 0.9.2+mixin.0.8.2 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.spongepowered.asm.mixin.injection, annotation type: Inject">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.required.element.summary">Required</a>&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">Optional</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">Element</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.spongepowered.asm.mixin.injection</a></div>
<h1 title="Annotation Type Inject" class="title">Annotation Type Inject</h1>
</div>
<section class="description">
<hr>
<pre>@Target(METHOD)
@Retention(RUNTIME)
public @interface <span class="type-name-label">Inject</span></pre>
<div class="block">Specifies that this mixin method should inject a callback (or
 callback<b>s</b>) to itself in the target method(s) identified by
 <a href="#method()"><code>method()</code></a>.
 
 <p>Callbacks are simple injectors which simply inject a call to the decorated
 method (the <em>handler</em>) in the <em>target</em> method (or methods)
 selected by the selectors specified in <a href="#method()"><code>method()</code></a>. Callback Injectors
 can also capture arguments and local variables from the <em>target</em> for
 use in the handler.</p>
 
 <p>Callback handler methods should always return <tt>void</tt> and should
 have the same <tt>static</tt>-ness as their target (though it is allowable to
 have a <tt>static</tt> callback injected into an instance method, and for
 obvious reasons the inverse is not permitted).</p> 
 
 <h3>Basic usage</h3>
 
 <p>The simplest usage of <tt>&#064;Inject</tt> captures no context from the
 target scope. This is particularly useful if the injector is targetting
 multiple methods with different signatures. In this case only the 
 <a href="callback/CallbackInfo.html" title="class in org.spongepowered.asm.mixin.injection.callback"><code>CallbackInfo</code></a> (or <a href="callback/CallbackInfoReturnable.html" title="class in org.spongepowered.asm.mixin.injection.callback"><code>CallbackInfoReturnable</code></a> as appropriate) is
 required.</p>
 
 <blockquote><tt>private void onSomeEvent(CallbackInfo ci)</tt></blockquote>
 
 <h3>Capture target arguments</h3>
 
 <p>Callbacks can also capture the arguments passed to the target method. To
 do so specify the target arguments before the <a href="callback/CallbackInfo.html" title="class in org.spongepowered.asm.mixin.injection.callback"><code>CallbackInfo</code></a>:</p>
 
 <blockquote><tt>private void onSomeEvent(int arg1, String arg2,
      CallbackInfo ci)</tt></blockquote>
 
 <h3>Surrogate methods</h3>
 
 <p>If injecting into multiple methods with different target arguments it is 
 obviously possible to ignore the target arguments (see "Basic Usage" above)
 but this may be unsuitable if arguments from the target are required. If you
 need to inject into multiple methods but also wish to capture method
 arguments you may provide a <em>surrogate</em> method with the alternative
 signature. In fact you may provide as many surrogates as required by the
 injection. Surrogate methods much have the same name as the handler method
 and must be decorated with <a href="Surrogate.html" title="annotation in org.spongepowered.asm.mixin.injection"><code>Surrogate</code></a>. A surrogate may also be
 required where the LVT of a method with <em>local capture</em> (see below) is
 known to change between different environments or injection points.</p>
 
 <h3>Capture local variables</h3>
 
 <p>In addition to capturing the target method arguments, it may be desirable
 to capture locally-scoped variables from the target method at the point of
 injection. This is usually executed in two stages:</p>
 
 <ol>
   <li>Set the <a href="#locals()"><code>locals()</code></a> value of your injection to
     <a href="callback/LocalCapture.html#PRINT"><code>LocalCapture.PRINT</code></a> and run the application.</li>
   <li>When the injector is processed, a listing of the LVT is produced
     accompanied by a generated signature for your handler method including
     the discovered args. Modify your handler signature accordingly.</li>
 </ol>
 
 <p>For more details see <a href="#locals()"><code>locals()</code></a>.</p></div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== ANNOTATION TYPE REQUIRED MEMBER SUMMARY =========== -->
<li>
<section class="member-summary" id="annotation.type.required.element.summary">
<h2>Required Element Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Required Elements</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Required Element</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code><a href="At.html" title="annotation in org.spongepowered.asm.mixin.injection">At</a>[]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#at()">at</a></span></code></th>
<td class="col-last">
<div class="block">Array of <a href="At.html" title="annotation in org.spongepowered.asm.mixin.injection"><code>At</code></a> annotations which describe the
 <a href="InjectionPoint.html" title="class in org.spongepowered.asm.mixin.injection"><code>InjectionPoint</code></a>s in the target method.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>java.lang.String[]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#method()">method</a></span></code></th>
<td class="col-last">
<div class="block">String representation of one or more
 <a href="selectors/ITargetSelector.html" title="interface in org.spongepowered.asm.mixin.injection.selectors"><code>target selectors</code></a> which identify the target
 methods.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== -->
<li>
<section class="member-summary" id="annotation.type.optional.element.summary">
<h2>Optional Element Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Optional Elements</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Optional Element</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#allow()">allow</a></span></code></th>
<td class="col-last">
<div class="block">Injection points are in general expected to match every candidate
 instruction in the target method or slice, except in cases where options
 such as <a href="At.html#ordinal()"><code>At.ordinal()</code></a> are specified which naturally limit the number
 of results.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#cancellable()">cancellable</a></span></code></th>
<td class="col-last">
<div class="block">Setting an injected callback to <em>cancellable</em> allows the injected
 callback to inject optional RETURN opcodes into the target method, the
 return behaviour can then be controlled from within the callback by
 interacting with the supplied <a href="callback/CallbackInfo.html" title="class in org.spongepowered.asm.mixin.injection.callback"><code>CallbackInfo</code></a> object.</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#constraints()">constraints</a></span></code></th>
<td class="col-last">
<div class="block">Returns constraints which must be validated for this injector to
 succeed.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#expect()">expect</a></span></code></th>
<td class="col-last">
<div class="block">Like <a href="#require()"><code>require()</code></a> but only enabled if the
 <a href="../MixinEnvironment.Option.html#DEBUG_INJECTORS"><code>mixin.debug.countInjections</code></a> option is set
 to <tt>true</tt> and defaults to 1.</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#id()">id</a></span></code></th>
<td class="col-last">
<div class="block">The identifier for this injector, can be retrieved via the
 <a href="callback/CallbackInfo.html#getId()"><code>CallbackInfo.getId()</code></a> accessor.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code><a href="callback/LocalCapture.html" title="enum in org.spongepowered.asm.mixin.injection.callback">LocalCapture</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#locals()">locals</a></span></code></th>
<td class="col-last">
<div class="block">Specifies the local variable capture behaviour for this injector.</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#remap()">remap</a></span></code></th>
<td class="col-last">
<div class="block">By default, the annotation processor will attempt to locate an
 obfuscation mapping for all <a href="Inject.html" title="annotation in org.spongepowered.asm.mixin.injection"><code>Inject</code></a> methods since it is
 anticipated that in general the target of a <a href="Inject.html" title="annotation in org.spongepowered.asm.mixin.injection"><code>Inject</code></a> annotation
 will be an obfuscated method in the target class.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#require()">require</a></span></code></th>
<td class="col-last">
<div class="block">In general, injectors are intended to "fail soft" in that a failure to
 locate the injection point in the target method is not considered an
 error condition.</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code><a href="Slice.html" title="annotation in org.spongepowered.asm.mixin.injection">Slice</a>[]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#slice()">slice</a></span></code></th>
<td class="col-last">
<div class="block">Array of <a href="Slice.html" title="annotation in org.spongepowered.asm.mixin.injection"><code>Slice</code></a> annotations which describe the method bisections
 used in the <a href="#at()"><code>at()</code></a> queries for this injector.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
</ul>
</section>
<section class="details" id="annotation.type.element.detail">
<ul class="details-list">
<!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== -->
<li>
<section class="member-details">
<h2>Element Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="method()">
<h3>method</h3>
<div class="member-signature"><span class="return-type">java.lang.String[]</span>&nbsp;<span class="member-name">method</span></div>
<div class="block">String representation of one or more
 <a href="selectors/ITargetSelector.html" title="interface in org.spongepowered.asm.mixin.injection.selectors"><code>target selectors</code></a> which identify the target
 methods.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>target method(s) for this injector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="at()">
<h3>at</h3>
<div class="member-signature"><span class="return-type"><a href="At.html" title="annotation in org.spongepowered.asm.mixin.injection">At</a>[]</span>&nbsp;<span class="member-name">at</span></div>
<div class="block">Array of <a href="At.html" title="annotation in org.spongepowered.asm.mixin.injection"><code>At</code></a> annotations which describe the
 <a href="InjectionPoint.html" title="class in org.spongepowered.asm.mixin.injection"><code>InjectionPoint</code></a>s in the target method. Allows one or more
 callbacks to be injected in the target method.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>injection point specifiers for this injector</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== -->
<li>
<section class="member-details">
<ul class="member-list">
<li>
<section class="detail" id="id()">
<h3>id</h3>
<div class="member-signature"><span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">id</span></div>
<div class="block">The identifier for this injector, can be retrieved via the
 <a href="callback/CallbackInfo.html#getId()"><code>CallbackInfo.getId()</code></a> accessor. If not specified, the ID defaults to
 the target method name.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the injector id to use</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>""</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="slice()">
<h3>slice</h3>
<div class="member-signature"><span class="return-type"><a href="Slice.html" title="annotation in org.spongepowered.asm.mixin.injection">Slice</a>[]</span>&nbsp;<span class="member-name">slice</span></div>
<div class="block">Array of <a href="Slice.html" title="annotation in org.spongepowered.asm.mixin.injection"><code>Slice</code></a> annotations which describe the method bisections
 used in the <a href="#at()"><code>at()</code></a> queries for this injector.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>slices</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>{}</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cancellable()">
<h3>cancellable</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="member-name">cancellable</span></div>
<div class="block">Setting an injected callback to <em>cancellable</em> allows the injected
 callback to inject optional RETURN opcodes into the target method, the
 return behaviour can then be controlled from within the callback by
 interacting with the supplied <a href="callback/CallbackInfo.html" title="class in org.spongepowered.asm.mixin.injection.callback"><code>CallbackInfo</code></a> object.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>true if this injector should inject appropriate RETURN opcodes
      which allow it to be cancelled</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>false</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="locals()">
<h3>locals</h3>
<div class="member-signature"><span class="return-type"><a href="callback/LocalCapture.html" title="enum in org.spongepowered.asm.mixin.injection.callback">LocalCapture</a></span>&nbsp;<span class="member-name">locals</span></div>
<div class="block">Specifies the local variable capture behaviour for this injector.
 
 <p>When capturing local variables in scope, the variables are appended to
 the callback invocation after the <a href="callback/CallbackInfo.html" title="class in org.spongepowered.asm.mixin.injection.callback"><code>CallbackInfo</code></a> argument.</p>
 
 <p>Capturing local variables from the target scope requires careful
 planning because unlike other aspects of an injection (such as the target
 method name and signature), the local variable table is <b>not</b> safe
 from modification by other transformers which may be in use in the
 production environment. Even other injectors which target the same target
 method have the ability to modify the local variable table and thus it is
 in no way safe to assume that local variables in scope at development
 time will be so in production.</p>
 
 <p>To provide some level of flexibility, especially where changes can be
 anticipated (for example a well-known mod makes changes which result in a
 particular structure for the local variable table) it is possible to
 provide <em>overloads</em> for the handler method which will become
 surrogate targets for the orphaned injector by annotating them with an
 <a href="Surrogate.html" title="annotation in org.spongepowered.asm.mixin.injection"><code>Surrogate</code></a> annotation.</p>
 
 <p>You can improve the robustness of your local capture injection by only
 specifying locals up to the last variable you wish to use. For example if
 the target LVT contains <tt>&lt;int, int, int, float, String&gt;</tt> and
 you only need the <tt>float</tt> value, you can choose to omit the unused
 <tt>String</tt> and changes to the LVT beyond that point will not affect
 your injection.</p>
 
 <p>It is also important to nominate the failure behaviour to follow when
 local capture fails and so all <a href="callback/LocalCapture.html" title="enum in org.spongepowered.asm.mixin.injection.callback"><code>LocalCapture</code></a> behaviours which
 specify a capture action imply a particular behaviour for handling
 failure. See the javadoc on the <a href="callback/LocalCapture.html" title="enum in org.spongepowered.asm.mixin.injection.callback"><code>LocalCapture</code></a> members for more
 details.</p>
 
 <p>Determining what local variables are available to you and in what
 order can be somewhat tricky, and so a simple mechanism for enumerating
 available locals is provided. By setting <code>locals</code> to
 <a href="callback/LocalCapture.html#PRINT"><code>LocalCapture.PRINT</code></a>, the injector writes the local capture state
 to STDERR instead of injecting the callback. Using the output thus
 obtained it is then a straightforward matter of altering the callback
 method signature to match the signature proposed by the Callback
 Injector.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the desired local capture behaviour for this injector</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>NO_CAPTURE</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="remap()">
<h3>remap</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="member-name">remap</span></div>
<div class="block">By default, the annotation processor will attempt to locate an
 obfuscation mapping for all <a href="Inject.html" title="annotation in org.spongepowered.asm.mixin.injection"><code>Inject</code></a> methods since it is
 anticipated that in general the target of a <a href="Inject.html" title="annotation in org.spongepowered.asm.mixin.injection"><code>Inject</code></a> annotation
 will be an obfuscated method in the target class. However since it is
 possible to also apply mixins to non-obfuscated targets (or non-
 obfuscated methods in obfuscated targets, such as methods added by Forge)
 it may be necessary to suppress the compiler error which would otherwise
 be generated. Setting this value to <em>false</em> will cause the
 annotation processor to skip this annotation when attempting to build the
 obfuscation table for the mixin.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>True to instruct the annotation processor to search for
      obfuscation mappings for this annotation</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>true</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="require()">
<h3>require</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="member-name">require</span></div>
<div class="block">In general, injectors are intended to "fail soft" in that a failure to
 locate the injection point in the target method is not considered an
 error condition. Another transformer may have changed the method
 structure or any number of reasons may cause an injection to fail. This
 also makes it possible to define several injections to achieve the same
 task given <em>expected</em> mutation of the target class and the
 injectors which fail are simply ignored.
 
 <p>However, this behaviour is not always desirable. For example, if your
 application depends on a particular injection succeeding you may wish to
 detect the injection failure as an error condition. This argument is thus
 provided to allow you to stipulate a <b>minimum</b> number of successful
 injections for this callback handler. If the number of injections
 specified is not achieved then an <a href="throwables/InjectionError.html" title="class in org.spongepowered.asm.mixin.injection.throwables"><code>InjectionError</code></a> is thrown at
 application time. Use this option with care.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Minimum required number of injected callbacks, default specified
      by the containing config</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>-1</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="expect()">
<h3>expect</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="member-name">expect</span></div>
<div class="block">Like <a href="#require()"><code>require()</code></a> but only enabled if the
 <a href="../MixinEnvironment.Option.html#DEBUG_INJECTORS"><code>mixin.debug.countInjections</code></a> option is set
 to <tt>true</tt> and defaults to 1. Use this option during debugging to
 perform simple checking of your injectors. Causes the injector to throw
 a <a href="throwables/InvalidInjectionException.html" title="class in org.spongepowered.asm.mixin.injection.throwables"><code>InvalidInjectionException</code></a> if the expected number of injections
 is not realised.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Minimum number of <em>expected</em> callbacks, default 1</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>1</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allow()">
<h3>allow</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="member-name">allow</span></div>
<div class="block">Injection points are in general expected to match every candidate
 instruction in the target method or slice, except in cases where options
 such as <a href="At.html#ordinal()"><code>At.ordinal()</code></a> are specified which naturally limit the number
 of results.
 
 <p>This option allows for sanity-checking to be performed on the results
 of an injection point by specifying a maximum allowed number of matches,
 similar to that afforded by <a href="Group.html#max()"><code>Group.max()</code></a>. For example if your
 injection is expected to match 4 invocations of a target method, but
 instead matches 5, this can become a detectable tamper condition by
 setting this value to <tt>4</tt>.
 
 <p>Setting any value 1 or greater is allowed. Values less than 1 or less
 than <a href="#require()"><code>require()</code></a> are ignored. <a href="#require()"><code>require()</code></a> supercedes this
 argument such that if <tt>allow</tt> is less than <tt>require</tt> the
 value of <tt>require</tt> is always used.</p>
 
 <p>Note that this option is not a <i>limit</i> on the query behaviour of
 this injection point. It is only a sanity check used to ensure that the
 number of matches is not too high</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Maximum allowed number of injections for this</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>-1</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="constraints()">
<h3>constraints</h3>
<div class="member-signature"><span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">constraints</span></div>
<div class="block">Returns constraints which must be validated for this injector to
 succeed. See <a href="../../util/ConstraintParser.Constraint.html" title="class in org.spongepowered.asm.util"><code>ConstraintParser.Constraint</code></a> for details of constraint formats.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Constraints for this annotation</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>""</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.required.element.summary">Required</a>&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">Optional</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">Element</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
